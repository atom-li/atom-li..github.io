<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="only one">
<meta property="og:type" content="website">
<meta property="og:title" content="AtomOne">
<meta property="og:url" content="http://liyy.org/page/5/index.html">
<meta property="og:site_name" content="AtomOne">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AtomOne">






  <link rel="canonical" href="http://liyy.org/page/5/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>AtomOne</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AtomOne</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">一个默默无闻的技术Cat</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Startseite</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />Über</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Kategorien</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archiv</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2017/02/11/3、Android/1、Android 基础/基本知识/SDK/Android aapt命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/11/3、Android/1、Android 基础/基本知识/SDK/Android aapt命令/" itemprop="url">
                  Android AAPT 命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2017-02-11 11:41:51" itemprop="dateCreated datePublished" datetime="2017-02-11T11:41:51+08:00">2017-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-04-18 14:05:24" itemprop="dateModified" datetime="2018-04-18T14:05:24+08:00">2018-04-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android-AAPT-命令"><a href="#Android-AAPT-命令" class="headerlink" title="Android AAPT 命令"></a>Android AAPT 命令</h2><p> <a href="https://my.oschina.net/u/1433837/blog/1605289" target="_blank" rel="noopener">Android aapt命令介绍及常用命令实践</a><br>引言</p>
<p>朋友要查看一个已存在包的versionCode信息，在群里面询问，由于是已经存在的apk包，并且只需要其中的versionCode信息，笔者就给发了一段aapt命令：aapt dump badging &lt;files.apk&gt; 下面针对aapt 命令做一下介绍，之前笔者也对一些常用adb命令也做过介绍：总结一些常用Android adb 命令，了解这些命令以后，可以更方便我们开发，提高开发效率。在这笔者在网上随便下载了一个app作为演示用。<br>aapt 命令大全</p>
<p>aapt d[ump] [–values] WHAT file.{apk} [asset [asset …]]</p>
<p>badging</p>
<p>Print the label and icon for the app declared in APK. 打印APK中声明的应用程序的标签和图标。</p>
<p>aapt dump badging</p>
<p>permissions</p>
<p>Print the permissions from the APK. 打印APK中声明的权限信息</p>
<p>aapt dump permissions</p>
<p><strong>resources </strong></p>
<p>Print the resource table from the APK. 打印APK中的资源表</p>
<p>aapt dump resources </p>
<p>configurations</p>
<p>Print the configurations in the APK. 打印APK中的配置信息</p>
<p>aapt dump configurations</p>
<p>xmltree</p>
<p>Print the compiled xmls in the given assets. 打印指定apk的指定xml文件。</p>
<p>aapt dump configurations</p>
<p>xmlstrings</p>
<p>Print the strings of the given compiled xml assets. 打印xml文件中所有的字符串信息</p>
<p>aapt dump xmlstrings</p>
<p>aapt l[ist] [-v] [-a] file.{zip,jar,apk}</p>
<p>List contents of Zip-compatible archive. 列出压缩文件目录</p>
<p>aapt list &lt;file.apk&gt;</p>
<p>aapt list</p>
<p>aapt list -v &lt;file.apk&gt;</p>
<p>会以table的形式输出目录</p>
<p>aapt list -v</p>
<p>aapt list -a &lt;file.apk&gt;</p>
<p>详细输出所有目录的内容(= aapt list)</p>
<p>其他aapt 命令(不常用，不做演示，有兴趣可以自己试一下)</p>
<p>aapt r[emove] [-v] file.{zip,jar,apk} file1 [file2 …]</p>
<p>Delete specified files from Zip-compatible archive.</p>
<p>aapt a[dd] [-v] file.{zip,jar,apk} file1 [file2 …]</p>
<p>Add specified files to Zip-compatible archive.</p>
<p>aapt v[ersion]</p>
<p>Print program version.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2017/02/10/3、Android/2、Android 进阶/源码分析/Activity 启动流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/3、Android/2、Android 进阶/源码分析/Activity 启动流程/" itemprop="url">
                  Activity 启动流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2017-02-10 11:02:59" itemprop="dateCreated datePublished" datetime="2017-02-10T11:02:59+08:00">2017-02-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2017-11-24 09:34:38" itemprop="dateModified" datetime="2017-11-24T09:34:38+08:00">2017-11-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Activity-启动流程"><a href="#Activity-启动流程" class="headerlink" title="Activity 启动流程"></a>Activity 启动流程</h1>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2017/02/10/3、Android/2、Android 进阶/源码分析/Binder 机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/3、Android/2、Android 进阶/源码分析/Binder 机制/" itemprop="url">
                  Android Binder 机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2017-02-10 11:02:59" itemprop="dateCreated datePublished" datetime="2017-02-10T11:02:59+08:00">2017-02-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2017-11-24 09:34:57" itemprop="dateModified" datetime="2017-11-24T09:34:57+08:00">2017-11-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android-Binder-机制"><a href="#Android-Binder-机制" class="headerlink" title="Android Binder 机制"></a>Android Binder 机制</h1>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2017/02/10/3、Android/2、Android 进阶/NDK/JIN/jni代码编写规则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/3、Android/2、Android 进阶/NDK/JIN/jni代码编写规则/" itemprop="url">
                  jni代码编写规则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2017-02-10 11:02:59" itemprop="dateCreated datePublished" datetime="2017-02-10T11:02:59+08:00">2017-02-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-04-18 14:06:30" itemprop="dateModified" datetime="2018-04-18T14:06:30+08:00">2018-04-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="jni代码编写规则"><a href="#jni代码编写规则" class="headerlink" title="jni代码编写规则"></a>jni代码编写规则</h2><h3 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h3><h4 id="1、java参数类型和jni本地参数类型对照"><a href="#1、java参数类型和jni本地参数类型对照" class="headerlink" title="1、java参数类型和jni本地参数类型对照"></a>1、java参数类型和jni本地参数类型对照</h4><table>
<thead>
<tr>
<th>Java 类型</th>
<th>jni本地类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>jboolean</td>
<td>C/C++ unsigned 8 bits</td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
<td>C/C++ signed 8 bits</td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
<td>C/C++ unsigned 16 bits</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>C/C++ signed 16 bits</td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
<td>C/C++ signed 32 bits</td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
<td>C/C++ signed 64 bits</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>C/C++  32位浮点型</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>C/C++  64位浮点型</td>
</tr>
<tr>
<td>void</td>
<td>void</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对象类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>jni本地类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object</td>
<td>jobject</td>
<td>任何Java对象，或者没有对应的java类型的对象</td>
</tr>
<tr>
<td>Class</td>
<td>jclass</td>
<td>class对象</td>
</tr>
<tr>
<td>String</td>
<td>jstring</td>
<td>字符串对象</td>
</tr>
</tbody>
</table>
<blockquote>
<p>数组类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>jni本地类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean[]</td>
<td>jbooleanArray</td>
<td>布尔型数组 unsigned</td>
</tr>
<tr>
<td>byte[]</td>
<td>jbyteArray</td>
<td>比特型数组 signed</td>
</tr>
<tr>
<td>char[]</td>
<td>jcharArray</td>
<td>字符型数组 unsigned</td>
</tr>
<tr>
<td>short[]</td>
<td>jshortArray</td>
<td>短整型数组 signed</td>
</tr>
<tr>
<td>int[]</td>
<td>jintArray</td>
<td>整型数组 signed</td>
</tr>
<tr>
<td>long[]</td>
<td>jlongArray</td>
<td>长整型数组 signed</td>
</tr>
<tr>
<td>float[]</td>
<td>jfloatArray</td>
<td>浮点型数组</td>
</tr>
<tr>
<td>double[]</td>
<td>jdoubleArray</td>
<td>双浮点型数组</td>
</tr>
<tr>
<td>Object[]</td>
<td>jobjectArray</td>
<td>任何对象的数组</td>
</tr>
</tbody>
</table>
<h3 id="2、JNI引用类型与Java的对应关系如下树层次图："><a href="#2、JNI引用类型与Java的对应关系如下树层次图：" class="headerlink" title="2、JNI引用类型与Java的对应关系如下树层次图："></a>2、JNI引用类型与Java的对应关系如下树层次图：</h3><ul>
<li>java中的返回值void和JNI中的void是完全对应的。<br><img src="http://oymp4z5xr.bkt.clouddn.com/17-11-21/71727895.jpg" alt=""> </li>
<li><p>java中的基本数据类型（boolean ，byte , char ，short ,int,long,float,double八种）在JNI中对应的数据类型只要在前面加上j就对应了（jboolean ，jbyte , jchar ，jshort ,jint,jlong,jfloat,jdouble）。<br>JNI中还有个Java中没有的jsize,定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 其实jsize整型是用来描述基本指标和大小。</span><br><span class="line">   <span class="keyword">typedef</span> jint jsize;</span><br></pre></td></tr></table></figure>
</li>
<li><p>java中的对象，包括类库中定义的类、接口以及自定义的类接口，都对应于JNI中的jobject。</p>
</li>
<li>java中基本数据类型的数组对应与JNI中的j<type>array类型。（type就是上面说的8种基本数据类型）</type></li>
<li>java中对象的数组对应于JNI中的jobjectArray类型。（在java中一切对象、接口以及数组都是对象）<blockquote>
<p><a href="http://blog.csdn.net/xyz_lmn/article/details/6956003" target="_blank" rel="noopener">http://blog.csdn.net/xyz_lmn/article/details/6956003</a><br><a href="http://www.cnblogs.com/liangwind/archive/2009/08/18/1925515.html" target="_blank" rel="noopener">http://www.cnblogs.com/liangwind/archive/2009/08/18/1925515.html</a></p>
</blockquote>
</li>
</ul>
<h3 id="3、Java基本类型的精度"><a href="#3、Java基本类型的精度" class="headerlink" title="3、Java基本类型的精度"></a>3、Java基本类型的精度</h3><p>java 的基本数据类型是不存在有符号和无符号这种概念的. JAVA中的基本数据类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。</p>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>字节数</th>
<th>范围/精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4</td>
<td>32位IEEE754单精度</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>64位IEEE754双精度</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>-128到127</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32,768到32,767</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2,147,483,648到2,147,483,647</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>整个Unicode字符集</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>True或者false</td>
</tr>
</tbody>
</table>
<p>像byte 是范围是 -128到127, 你想要变为 0到255 怎么办, 跟 0XFF 做与运算 就可以了.<br>如 byte bb , 如果你想赋值它值 255, 那是不行的, 就算赋值了, bb 的值也是 255 对 256 求模后的值 -1<br>　　    如果你只是想取他 0到255 的值, 还是很简单的,<br>　　    bb &amp; 0XFF  , 如 bb = -1,  那 bb &amp; 0XFF 结果为 255,<br>　　    这个与运算后的结果会隐式转换为int 类型的, 因为 byte 放不下了.<br>与运算 还是很快的, 比加减法还快的.<br><a href="http://www.stuhack.com/biancheng/java/35169.html" target="_blank" rel="noopener">http://www.stuhack.com/biancheng/java/35169.html</a></p>
<h2 id="二、jni层使用java的基本类型数据"><a href="#二、jni层使用java的基本类型数据" class="headerlink" title="二、jni层使用java的基本类型数据"></a>二、jni层使用java的基本类型数据</h2><p>对于上面八种基本的数据类型boolean ，byte , char ，short ,int,long,float,double，jni层的c++代码可以用强制直接转换成对于长度的c/c++类型数据。<br>如：unsigned char tmp = (unsigned char) m_jboolean;<br>    unsigned short tmp = (unsigned short)m_jchar;<br>    或者同长度类型的数据就可以直接赋值的，int tmp = m_jint;</p>
<h2 id="三、jni层对数组的使用"><a href="#三、jni层对数组的使用" class="headerlink" title="三、jni层对数组的使用"></a>三、jni层对数组的使用</h2><p>JNI通过JNIEnv提供的操作Java数组的功能。它提供了两个函数：一个是操作java的简单型数组的，另一个是操作对象类型数组的。</p>
<ol>
<li>操作java的简单型数组<br>因为速度的原因，简单类型的数组作为指向本地类型的指针暴露给本地代码。因此，它们能作为常规的数组存取。这个指针是指向实际的Java数组或者Java数组的拷贝的指针。另外，数组的布置保证匹配本地类型。<br>为了存取Java简单类型的数组，你就要要使用GetXXXArrayElements函数（见表三），XXX代表了数组的类型。这个函数把Java数组看成参数，返回一个指向对应的本地类型的数组的指针。<br> 完整的函数族见下表：<br>函数                         Java 数组类型  本地类型<br>GetBooleanArrayElements     jbooleanArray   jboolean<br>GetByteArrayElements         jbyteArray      jbyte<br>GetCharArrayElements         jcharArray      jchar<br>GetShortArrayElements        jshortArray     jshort<br>GetIntArrayElements          jintArray       jint<br>GetLongArrayElements         jlongArray      jlong<br>GetFloatArrayElements        jfloatArray     jfloat<br>GetDoubleArrayElements       jdoubleArray    jdouble</li>
</ol>
<p>当你对数组的存取完成后，要确保调用相应的ReleaseXXXArrayElements函数，参数是对应Java数组和GetXXXArrayElements返回的指针。如果必要的话，这个释放函数会复制你做的任何变化（这样它们就反射到java数组），然后释放所有相 关的资源。<br>例如：<br>static jint com_ginwave_fs_com_HWRC_GetRecogRange(JNIEnv<em> env, jclass clazz, jintArray Handle)<br>{<br>unsigned long </em>pHandle = NULL;<br>int ret = 0;<br>jint <em>tmpHandle = env-&gt;GetIntArrayElements(Handle, 0);<br>pHandle = (unsigned long </em>)tmpHandle;<br>ret = (int)HWRC_GetRecogRange(pHandle);<br>env-&gt;ReleaseIntArrayElements(Handle, tmpHandle, 0);<br>return r<br>}</p>
<p>获取数组的长度：<br>jint theArrayLength = env-&gt;GetArrayLength(Frame);</p>
<pre><code>创建一个新的函数数组簇如下：
</code></pre><p>NewBooleanArray<br>NewByteArray<br>NewCharArray<br>NewShortArray<br>NewIntArray<br>NewLongArray<br>NewFloatArray<br>NewDoubleArray<br>        参数为数组长度，如：<br>        jbyte *list;<br>        jbyteArray byteArray = NULL;<br>        byteArray = env-&gt;NewByteArray(len);<br>        if (byteArray)<br>            env-&gt;SetByteArrayRegion(byteArray, 0, len, list);</p>
<pre><code>关于函数簇GetXXXArrayRegion和SetXXXArrayRegion，其中XXX为基本类型。
例如：
env-&gt;SetByteArrayRegion(buffer, destOffset, count, (const jbyte *)address + srcOffset);
Setxxx的方向是从JNI层往java层传递；
env-&gt;GetByteArrayRegion(buffer, srcOffset, count, (jbyte *)address + destOffset);
而Getxxx的方向则是数据从java层向jni层传递。

这里是获取简单型数组中的数据供jni或者下层使用，如果需要在jni层设置java
</code></pre><p>中对于的简单型数组的话，就需要使用到接下来讲到的对象类型的一些操作。<br>    总结下，有以下几簇函数：<br>    GetArrayLength<br>    NewXXXArray<br>    GetXXXArrayElements<br>    ReleaseXXXArrayElements<br>    GetXXXArrayRegion<br>    SetXXXArrayRegion<br>    对于数据，暂时遇到这些函数了。。。</p>
<ol start="2">
<li>操作java对象类型数据<br>Java对象做为引用被传递到本地方法中，所有这些Java对象的引用都有一个共同的父类型jobject(相当于java中的Object类是所有类的父类一样)。</li>
</ol>
<p>1). string对象<br>从java程序中传过去的String对象在本地方法中对应的是jstring类型，jstring类型和c中的char<em>不同，所以如果你直接当做char</em>使用的话，就会出错。因此在使用之前需要将jstring转换成为c/c++中的char<em>，这里使用JNIEnv的方法转换。<br>static jstring  com_prompt_getLine(JNIEnv </em>env, jobject obj, jstring prompt)<br>{<br>char buf[128];<br>const char <em>str = (</em>env)-&gt;GetStringUTFChars(env, prompt, 0);<br>printf(“%s”, str);<br>env-&gt;ReleaseStringUTFChars(prompt, str);<br>…</p>
<p>}<br>这里使用GetStringUTFChars方法将传进来的prompt（jstring类型）转换成为UTF－8的格式，就能够在本地方法中使用了。<br>注意：在使用完你所转换之后的对象之后，需要显示调用ReleaseStringUTFChars方法，让JVM释放转换成UTF-8的string的对象的空间，如果不显示的调用的话，JVM中会一直保存该对象，不会被垃圾回收器回收，因此就会导致内存溢出。</p>
<p>下面是访问String的一些方法：<br>GetStringUTFChars        将jstring转换成为UTF-8格式的char<em><br>GetStringChars           将jstring转换成为Unicode格式的char</em><br>ReleaseStringUTFChars    释放指向UTF-8格式的char<em>的指针<br>ReleaseStringChars       释放指向Unicode格式的char</em>的指针<br>NewStringUTF             创建一个UTF-8格式的String对象<br>NewString                创建一个Unicode格式的String对象<br>GetStringUTFLength       获取UTF-8格式的char<em>的长度<br>GetStringLength          获取Unicode格式的char</em>的长度</p>
<p>提供给两个jstring和char <em>互相转换的函数：<br>/</em> c/c++ string turn to java jstring <em>/<br>static jstring strTojstring(JNIEnv</em> env, const unsigned char<em> pStr)<br>{<br>    int        strLen    = strlen((const char</em>)pStr);<br>    jclass     jstrObj   = env-&gt;FindClass(“java/lang/String”);<br>    jmethodID  methodId  = env-&gt;GetMethodID(jstrObj, “”, “([BLjava/lang/String;)V”);<br>    jbyteArray byteArray = env-&gt;NewByteArray(strLen);<br>    jstring    encode    = env-&gt;NewStringUTF(“utf-8”);</p>
<pre><code>env-&gt;SetByteArrayRegion(byteArray, 0, strLen, (jbyte*)pStr);

return (jstring)env-&gt;NewObject(jstrObj, methodId, byteArray, encode);
</code></pre><p>}<br>//check ok!</p>
<p>/<em> java jstring turn to c/c++ string </em>/<br>static char<em> jstringTostr(JNIEnv</em> env, jstring jstr)<br>{<br>    char* pStr = NULL;</p>
<pre><code>jclass     jstrObj   = env-&gt;FindClass(&quot;java/lang/String&quot;);
jstring    encode    = env-&gt;NewStringUTF(&quot;utf-8&quot;);
jmethodID  methodId  = env-&gt;GetMethodID(jstrObj, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);
jbyteArray byteArray = (jbyteArray)env-&gt;CallObjectMethod(jstr, methodId, encode);
jsize      strLen    = env-&gt;GetArrayLength(byteArray);
jbyte      *jBuf     = env-&gt;GetByteArrayElements(byteArray, JNI_FALSE);

if (jBuf &gt; 0)
{
    pStr = (char*)malloc(strLen + 1);

    if (!pStr)
    {
        return NULL;
    }

    memcpy(pStr, jBuf, strLen);

    pStr[strLen] = 0;
}

env-&gt;ReleaseByteArrayElements(byteArray, jBuf, 0);

return pStr;
</code></pre><p>}<br>// check ok!</p>
<pre><code>    2) 访问java对象
JNI提供的另外一个功能是在本地代码中使用Java对象。通过使用合适的JNI函数，你可以创建Java对象，get、set 静态(static)和 实例（instance）的域，调用静态(static)和实例（instance）函数。JNI通过ID识别域和方法，一个域或方法的ID是任何处理域和方法的函数的必须参数。
</code></pre><p>下表列出了用以得到静态(static)和实例（instance）的域与方法的JNI函数。每个函数接受（作为参数）域或方法的类，它们的名称，符号和它们对应返回的jfieldID或jmethodID。</p>
<pre><code>函数                    描述
</code></pre><p>GetFieldID              得到一个实例的域的ID<br>GetStaticFieldID        得到一个静态的域的ID<br>GetMethodID             得到一个实例的方法的ID<br>GetStaticMethodID       得到一个静态方法的ID</p>
<pre><code>下面以一个例子来说明用法：上下层之间需要传递一个或者多个结构体值。
c/c++结构体定义：
typedef struct tagTHWFrame{
    short left;
    short top;
    short width;
    short height;
</code></pre><p>} THWFrame;<br>当然在java层也需要定义一个匹配的类出来：<br>public class THWFrame{<br>    public short left;<br>    public short top;<br>    public short width;<br>    public short height;<br>}<br>注意貌似这里只能定义成public的。<br>下面是jni层相关的代码，主要思想是对java对应类对象的属性域获得ID值后一个一个访问。<br>/<em> int HWRC_SetInputBox( unsigned long </em>pHandle, const THWFrame <em>pFrame ); </em>/<br>static void ObjectTOTHWFrameStruct(JNIEnv<em> env, jobjectArray Frame, THWFrame </em>pFrame, int index)<br>{<br>    jobject obj = env-&gt;GetObjectArrayElement(Frame, index);<br>    jclass cls = env-&gt;GetObjectClass(obj);<br>    jfieldID left = env-&gt;GetFieldID(cls, “left”, “S”);<br>    pFrame[index].left = (short)env-&gt;GetShortField(obj, left);</p>
<pre><code>jfieldID top = env-&gt;GetFieldID(cls, &quot;top&quot;, &quot;S&quot;);
pFrame[index].top = (short)env-&gt;GetShortField(obj, top);

jfieldID width = env-&gt;GetFieldID(cls, &quot;width&quot;, &quot;S&quot;);
pFrame[index].width = (short)env-&gt;GetShortField(obj, width);

jfieldID height = env-&gt;GetFieldID(cls, &quot;height&quot;, &quot;S&quot;);
pFrame[index].height = (short)env-&gt;GetShortField(obj, height); 
</code></pre><p>}<br>static jint com_ginwave_fs_com_HWRC_SetInputBox(JNIEnv<em> env, jclass clazz,<br>            jintArray Handle, jobjectArray Frame)<br>{<br>    unsigned long </em>pHandle = NULL;<br>    THWFrame *pFrame = NULL;<br>    int frame_len = 0;<br>    int ret = 0;</p>
<pre><code>jint *tmpHandle = env-&gt;GetIntArrayElements(Handle, 0);
pHandle = (unsigned long *)tmpHandle;

jint theArrayLength = env-&gt;GetArrayLength(Frame);
frame_len = theArrayLength;
pFrame = (THWFrame *)malloc( sizeof(THWFrame) * frame_len );

for( int i = 0; i &lt; frame_len; i++ ){
    ObjectTOTHWFrameStruct(env, Frame, pFrame, i);
}

ret = HWRC_SetInputBox(pHandle, (const THWFrame *)pFrame);

env-&gt;ReleaseIntArrayElements(Handle, tmpHandle, 0);
free(pFrame);
frame_len = NULL;

return ret;
</code></pre><p>}<br>// {“HWRC_SetInputBox”, “([I[Ljava/com/ginwave/fs/com/THWFrame)I” , (void *)com_ginwave_fs_com_HWRC_SetInputBox },<br>// check ok!</p>
<p>/<em> int HWRC_GetInputBox( unsigned long </em>pHandle, THWFrame <em>pFrame ); </em>/<br>static void THWFrameStructTOObject(JNIEnv<em> env, jobjectArray Frame, THWFrame </em>pFrame, int index)<br>{<br>    jobject obj = env-&gt;GetObjectArrayElement(Frame, index);<br>    jclass cls = env-&gt;GetObjectClass(obj);<br>    jfieldID left = env-&gt;GetFieldID(cls, “left”, “S”);<br>    env-&gt;SetShortField(obj, left, (short)pFrame[index].left);</p>
<pre><code>jfieldID top = env-&gt;GetFieldID(cls, &quot;top&quot;, &quot;S&quot;);
env-&gt;SetShortField(obj, top, (short)pFrame[index].top);

jfieldID width = env-&gt;GetFieldID(cls, &quot;width&quot;, &quot;S&quot;);
env-&gt;SetShortField(obj, width, (short)pFrame[index].width);

jfieldID height = env-&gt;GetFieldID(cls, &quot;height&quot;, &quot;S&quot;);
env-&gt;SetShortField(obj, height, (short)pFrame[index].height);
</code></pre><p>}<br>static jint com_ginwave_fs_com_HWRC_GetInputBox(JNIEnv<em> env, jclass clazz,<br>            jintArray Handle, jobjectArray Frame)<br>{<br>    unsigned long </em>pHandle = NULL;<br>    THWFrame *pFrame = NULL;<br>    int frame_len = 0;<br>    int ret = 0;</p>
<pre><code>jint *tmpHandle = env-&gt;GetIntArrayElements(Handle, 0);
pHandle = (unsigned long *)tmpHandle;

jint theArrayLength = env-&gt;GetArrayLength(Frame);
frame_len = theArrayLength;
pFrame = (THWFrame *)malloc( sizeof(THWFrame) * frame_len );

ret = HWRC_GetInputBox(pHandle, pFrame);

for( int i = 0; i &lt; frame_len; i++ ){
    THWFrameStructTOObject(env, Frame, pFrame, i);
}

env-&gt;ReleaseIntArrayElements(Handle, tmpHandle, 0);
free(pFrame);
frame_len = NULL;

return ret;
</code></pre><p>}<br>// {“HWRC_GetInputBox”, “([I[Ljava/com/ginwave/fs/com/THWFrame)I” , (void *)com_ginwave_fs_com_HWRC_GetInputBox },<br>// check ok!</p>
<p>其中，比较难理解的应该是函数的签名了，下面是他们的一些规则：<br>这个数组的类型是JNINativeMethod，定义如下：<br>typedef struct {<br>const char<em> name;<br>const char</em> signature;<br>void* fnPtr;<br>} JNINativeMethod;</p>
<p>第一个变量name是Java中函数的名字。<br>第二个变量signature，用字符串是描述了函数的参数和返回值<br>第三个变量fnPtr是函数指针，指向C函数。</p>
<p>其中比较难以理解的是第二个参数，例如<br>“()V”<br>“(II)V”<br>“(Ljava/lang/String;Ljava/lang/String;)V”</p>
<p>实际上这些字符是与函数的参数类型一一对应的。<br>“()” 中的字符表示参数，后面的则代表返回值。例如”()V” 就表示void Func();<br>“(II)V” 表示 void Func(int, int);<br>具体的每一个字符的对应关系如下</p>
<p>字符             Java类型      C类型<br>V              void              void<br>Z              jboolean     boolean<br>I              jint         int<br>J                     jlong             long<br>D              jdouble           double<br>F               jfloat              float<br>B              jbyte             byte<br>C              jchar                     char<br>S               jshort             short</p>
<p>数组则以”[“开始，用两个字符表示<br>[I       jintArray          int[]<br>[F       jfloatArray         float[]<br>[B       jbyteArray          byte[]<br>[C        jcharArray          char[]<br>[S        jshortArray          short[]<br>[D       jdoubleArray         double[]<br>[J        jlongArray         long[]<br>[Z        jbooleanArray      boolean[]</p>
<p>objects对象          Lfully-qualified-class-name;         L类名<br>Arrays数组          [array-type                                 [数组类型</p>
<p>方法参数或者返回值为java中的对象时，必须以“L”加上其路径，不过此路径必须以“/”分开，自定义的对象也使用本规则，不在包中时直接“L”加上类名称。比如说 java.lang.String为“java/lang/String”,com.nedu.jni.helloword.Student为”com /nedu/jni/helloword/Student”</p>
<p>方法参数或者返回值为数组时类型前加上[,例如[I表示 int[],[[[D表示 double[][][]，即几维数组就加几个[。</p>
<p>JNI函数中始终包含两个必要的参数：JNIEnv<em> env, jclass clazz<br>JNIEnv </em>――它是一个接口指针，用于定位函数表中的函数！<br>在JNI规范中一般称  为   “Interface Pointer”。看到这儿好像和过程调用很类似了！是的，JNI中的操作过程，就是面向过程的！后面的jobject是  一个指向该类的指针，类似与C语言中的this。这个第二个参数是变化的，当该方法为类的实例方法时该参数为jobject；当该方法为类方法 （即静态方法）时该参数为jclass，指向该类的class。<br>通过ndk编程来得到jni层头文件的时候，这第二个参数对于staic方法，生成出来的就是jclass，而对于非staic方法，生成出来的就是jobject。</p>
<p>从上图可知，jobject包含了其实概括了所有的java类型，也就是说，像上图中的非jobject类型的数据，在传递参数的时候都可以以jobject类型传递下去。比如说，如果要java中要传递一个二(多)维int数组下去，就可以包装成jobjectArray传下去，只不过对应的签名要弄成[[I了。</p>
<p>对于访问java对象的方法<br>在本地方法中调用Java对象的方法的步骤：<br>①.获取你需要访问的Java对象的类：<br>jclass cls = (<em>env)-&gt;GetObjectClass(env, obj);   // FindClass(“android/util/log”)<br>使用GetObjectClass方法获取obj对应的jclass。 // 直接搜索类名，需要是static修饰的类。<br>②.获取MethodID：<br>jmethodID mid = (</em>env)-&gt;GetMethodID(env, cls, “callback”, “(I)V”);<br>// GetStaticMethodID(…)  , 获取静态方法的ID<br>使用GetMethdoID方法获取你要使用的方法的MethdoID。其参数的意义：<br>env–&gt;JNIEnv<br>cls–&gt;第一步获取的jclass<br>“callback”–&gt;要调用的方法名<br>“(I)V”–&gt;方法的Signature, 签名同前面的JNI规则。<br>③.调用方法：<br>(*env)-&gt;CallVoidMethod(env, obj, mid, depth);<br>// CallStaticIntMethod(….) ， 调用静态方法<br>使用CallVoidMethod方法调用方法。参数的意义：<br>env–&gt;JNIEnv<br>obj–&gt;通过本地方法穿过来的jobject<br>mid–&gt;要调用的MethodID（即第二步获得的MethodID）<br>depth–&gt;方法需要的参数（对应方法的需求，添加相应的参数）<br>注：这里使用的是CallVoidMethod方法调用，因为没有返回值，如果有返回值的话使用对应的方法，在后面会提到。<br>CallVoidMethod               CallStaticVoidMethod<br>CallIntMethod                     CallStaticVoidMethod<br>CallBooleanMethod              CallStaticVoidMethod<br>CallByteMethod                   CallStaticVoidMethod<br>…<br>其实jni中还有很多很多的接口函数这里没有列举，可以直接参考源码：<br>$ find  frameworks/base  type d  -name  jni<br>./voip/jni<br>./rfid/jni<br>./freestylus/jni<br>./native/graphics/jni<br>./drm/jni<br>./tests/BrowserTestPlugin/jni<br>./services/jni<br>./packages/TtsService/jni<br>./media/jni<br>./media/libdrm/mobile1/include/jni<br>./media/libdrm/mobile1/src/jni<br>./graphics/jni<br>./core/jni<br>./opengl/tests/gl_jni/jni<br>./opengl/tests/gl2_jni/jni<br>./opengl/tests/gldual/jni<br>这么多jni目录都可以参考，其中主要是core/jni目录了。<br>四、关于异常<br>异常接口有：<br>jniThrowException(env, “java/lang/RuntimeException”, “Method called after release()”);<br>env-&gt;ThrowNew(env-&gt;FindClass(“java/io/IOException”),”CWJLog Error, IOException”);<br>doThrow(env, “java/lang/IllegalStateException”, msg);<br>使用Throw，自己构造(没用过)<br>jclass clazz = env-&gt;FindClass(“java/io/IOException”);<br>jmethodID methodId = env-&gt;GetMethodID(clazz, “<init>“, “()V”);<br>jthrowable throwable = env-&gt;NewObject(clazz, methodId);<br>env-&gt;Throwthrowable);</init></p>
<p>参考网址：<br><a href="http://blog.csdn.net/xyz_lmn/article/details/6959545" target="_blank" rel="noopener">http://blog.csdn.net/xyz_lmn/article/details/6959545</a><br> Android JNI入门第三篇——jni头文件分析<br><a href="http://blog.csdn.net/xyz_lmn/article/details/6966259" target="_blank" rel="noopener">http://blog.csdn.net/xyz_lmn/article/details/6966259</a><br> Android JNI入门第四篇——Android.mk文件分析<br><a href="http://blog.csdn.net/xyz_lmn/article/details/7017420" target="_blank" rel="noopener">http://blog.csdn.net/xyz_lmn/article/details/7017420</a><br> Android JNI开发提高篇<br><a href="http://blog.csdn.net/xyz_lmn/article/details/6956003" target="_blank" rel="noopener">http://blog.csdn.net/xyz_lmn/article/details/6956003</a><br> Android JNI入门第二篇——Java参数类型与本地参数类型对照</p>
<p><a href="http://wenku.baidu.com/view/e9e28ca1b0717fd5360cdc18.html" target="_blank" rel="noopener">http://wenku.baidu.com/view/e9e28ca1b0717fd5360cdc18.html</a><br>JNI入门<br><a href="http://www.ibm.com/developerworks/cn/java/j-jni/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-jni/</a><br>使用 Java Native Interface 的最佳实践<br><a href="http://helloxuweifu.iteye.com/blog/1168647" target="_blank" rel="noopener">http://helloxuweifu.iteye.com/blog/1168647</a><br><a href="http://blog.csdn.net/kangyaping/article/details/6584027" target="_blank" rel="noopener">http://blog.csdn.net/kangyaping/article/details/6584027</a><br>JNI函数调用大全</p>
<p><a href="http://newfaction.net/2010/11/30/java-jni-getfieldid-and-getmethodid-and-parameter-description.html" target="_blank" rel="noopener">http://newfaction.net/2010/11/30/java-jni-getfieldid-and-getmethodid-and-parameter-description.html</a><br>java jni GetFieldID 和 GetMethodID 以及参数的说明<br><a href="http://hi.baidu.com/spmno/blog/item/7d4d764ea78a6809b3de0588.html" target="_blank" rel="noopener">http://hi.baidu.com/spmno/blog/item/7d4d764ea78a6809b3de0588.html</a><br>jni中使用数组的几个方法<br><a href="http://xxw8393.blog.163.com/blog/static/3725683420107109411366/" target="_blank" rel="noopener">http://xxw8393.blog.163.com/blog/static/3725683420107109411366/</a><br>JNI 返回结构体参数<br><a href="http://www.cnblogs.com/nicholas_f/archive/2010/11/30/1892124.html" target="_blank" rel="noopener">http://www.cnblogs.com/nicholas_f/archive/2010/11/30/1892124.html</a><br>JNI中java类型与C/C++类型对应关系<br><a href="http://blog.csdn.net/sunny09290/article/details/6884994" target="_blank" rel="noopener">http://blog.csdn.net/sunny09290/article/details/6884994</a><br>JNI数据类型<br><a href="http://www.cnblogs.com/liangwind/archive/2009/08/18/1925515.html" target="_blank" rel="noopener">http://www.cnblogs.com/liangwind/archive/2009/08/18/1925515.html</a><br>jni　–c/c++　数据类型、数组、对象<br><a href="http://www.cnblogs.com/diyunpeng/archive/2009/09/24/1573296.html" target="_blank" rel="noopener">http://www.cnblogs.com/diyunpeng/archive/2009/09/24/1573296.html</a><br>Java有符号数与无符号数<br><a href="http://www.stuhack.com/biancheng/java/35169.html" target="_blank" rel="noopener">http://www.stuhack.com/biancheng/java/35169.html</a><br>Java的基本数据类型是无符号的</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2017/02/01/3、Android/2、Android 进阶/NDK/JIN/JNI 资源释放/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/01/3、Android/2、Android 进阶/NDK/JIN/JNI 资源释放/" itemprop="url">
                  JNI 资源释放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2017-02-01 11:02:59" itemprop="dateCreated datePublished" datetime="2017-02-01T11:02:59+08:00">2017-02-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-04-18 14:06:25" itemprop="dateModified" datetime="2018-04-18T14:06:25+08:00">2018-04-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JNI-资源释放"><a href="#JNI-资源释放" class="headerlink" title="JNI 资源释放"></a>JNI 资源释放</h2><pre><code>JNI 编程实现了 native code 和 Java 程序的交互，因此 JNI 代码编程既遵循 native code 编程语言的编程规则，同时也遵守 JNI 编程的文档规范。在内存管理方面，native code 编程语言本身的内存管理机制依然要遵循，同时也要考虑 JNI 编程的内存管理。
本章简单概括 JNI 编程中显而易见的内存泄漏。从 native code 编程语言自身的内存管理，和 JNI 规范附加的内存管理两方面进行阐述。
</code></pre><h3 id="1、Native-Code-本身的内存泄漏"><a href="#1、Native-Code-本身的内存泄漏" class="headerlink" title="1、Native Code 本身的内存泄漏"></a>1、Native Code 本身的内存泄漏</h3><pre><code>JNI 编程首先是一门具体的编程语言，或者 C 语言，或者 C++，或者汇编，或者其它 native 的编程语言。每门编程语言环境都实现了自身的内存管理机制。因此，JNI 程序开发者要遵循 native 语言本身的内存管理机制，避免造成内存泄漏。以 C 语言为例，当用 malloc() 在进程堆中动态分配内存时，JNI 程序在使用完后，应当调用 free() 将内存释放。总之，所有在 native 语言编程中应当注意的内存泄漏规则，在 JNI 编程中依然适应。
Native 语言本身引入的内存泄漏会造成 native memory 的内存，严重情况下会造成 native memory 的 out of memory。
</code></pre><h3 id="2、Global-Reference-引入的内存泄漏"><a href="#2、Global-Reference-引入的内存泄漏" class="headerlink" title="2、Global Reference 引入的内存泄漏"></a>2、Global Reference 引入的内存泄漏</h3><pre><code>JNI 编程还要同时遵循 JNI 的规范标准，JVM 附加了 JNI 编程特有的内存管理机制。
JNI 中的 Local Reference 只在 native method 执行时存在，当 native method 执行完后自动失效。这种自动失效，使得对 Local Reference 的使用相对简单，native method 执行完后，它们所引用的 Java 对象的 reference count 会相应减 1。不会造成 Java Heap 中 Java 对象的内存泄漏。
而 Global Reference 对 Java 对象的引用一直有效，因此它们引用的 Java 对象会一直存在 Java Heap 中。程序员在使用 Global Reference 时，需要仔细维护对 Global Reference 的使用。如果一定要使用 Global Reference，务必确保在不用的时候删除。就像在 C 语言中，调用 malloc() 动态分配一块内存之后，调用 free() 释放一样。否则，Global Reference 引用的 Java 对象将永远停留在 Java Heap 中，造成 Java Heap 的内存泄漏。
</code></pre><h3 id="3、资源释放"><a href="#3、资源释放" class="headerlink" title="3、资源释放"></a>3、资源释放</h3><p>1、什么需要释放？　<br>什么需要什么呢 ？ JNI 基本数据类型是不需要释放的 ， 如 jint , jlong , jchar 等等 。 我们需要释放是引用数据类型，当然也包括数组家族。如：jstring ，jobject ，jobjectArray，jintArray 等等。<br>当然，大家可能经常忽略掉的是 jclass ，jmethodID ， 这些也是需要释放的哦<br>2、如何去释放？</p>
<ul>
<li><p>释放String</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jstring jstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span>* cstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">jstr = (*jniEnv)-&gt;CallObjectMethod(jniEnv, mPerson, getName);</span><br><span class="line">cstr = (<span class="keyword">char</span> * ) ( * jniEnv)-&gt;GetStringUTFChars(jniEnv,jstr, <span class="number">0</span>);</span><br><span class="line">__android_log_print(ANDROID_LOG_INFO, <span class="string">"JNIMsg"</span>, <span class="string">"getName  ---- &gt;  %s"</span>,cstr );</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">(*jniEnv)-&gt;ReleaseStringUTFChars(jniEnv, jstr, cstr);</span><br><span class="line">(*jniEnv)-&gt;DeleteLocalRef(jniEnv, jstr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放 类 、对象、方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*jniEnv)-&gt;DeleteLocalRef(jniEnv, XXX);</span><br><span class="line"><span class="comment">//“XXX” 代表 引用对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放 数组家族</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jobjectArray arrays = <span class="literal">NULL</span>;</span><br><span class="line">jclass jclsStr = <span class="literal">NULL</span>;</span><br><span class="line">jclsStr = (*jniEnv)-&gt;FindClass(jniEnv, <span class="string">"java/lang/String"</span>);</span><br><span class="line">arrays = (*jniEnv)-&gt;NewObjectArray(jniEnv, len, jclsStr, <span class="number">0</span>);</span><br><span class="line">(*jniEnv)-&gt;DeleteLocalRef(jniEnv, jclsStr);  <span class="comment">//释放String类</span></span><br><span class="line">(*jniEnv)-&gt;DeleteLocalRef(jniEnv, arrays); <span class="comment">//释放jobjectArray数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>native method 调用 DeleteLocalRef() 释放某个 JNI Local Reference 时，首先通过指针 p 定位相应的 Local Reference 在 Local Ref 表中的位置，然后从 Local Ref 表中删除该 Local Reference，也就取消了对相应 Java 对象的引用（Ref count 减 1）。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2017/01/12/3、Android/2、Android 进阶/NDK/JIN/NDK 与 JNI 的关系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/12/3、Android/2、Android 进阶/NDK/JIN/NDK 与 JNI 的关系/" itemprop="url">
                  NDK 与 JNI 的关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2017-01-12 17:12:59" itemprop="dateCreated datePublished" datetime="2017-01-12T17:12:59+08:00">2017-01-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-04-18 14:06:33" itemprop="dateModified" datetime="2018-04-18T14:06:33+08:00">2018-04-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>JNI是java语言提供的Java和C/C++相互沟通的机制，Java可以通过JNI调用本地的C/C++代码，本地的C/C++的代码也可以调用java代码。JNI 是本地编程接口，Java和C/C++互相通过的接口。Java通过C/C++使用本地的代码的一个关键性原因在于C/C++代码的高效性。</p>
<h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><p>NDK是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。它集成了交叉编译器，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。它可以自动地将so和Java应用一起打包，极大地减轻了开发人员的打包工作。</p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>Java通过JNI机制和C/C++沟通的具体步骤<br>1、编写包含native本地方法的java类<br>2、通过javah工具生成C/C++语言的头文件<br>3、使用C/C++语言实现头文件<br>4、使用交叉编译工具对C/C++本地代码进行编译，最后通过链接生成*.so可执行的动态库<br>5、实际执行Java代码去和本地的C/C++代码互相沟通</p>
<h2 id="JNI中的JavaVM与JNIEnv对象"><a href="#JNI中的JavaVM与JNIEnv对象" class="headerlink" title="JNI中的JavaVM与JNIEnv对象"></a>JNI中的JavaVM与JNIEnv对象</h2><p>标准Java平台下，每一个Process可以产生很多JavaVM对象，但在Android平台上，每一个Process只能产生一个Dalvik VM对象，也就是说在Android进程中是通过一个虚拟器对象来服务所有Java和c/c++代码。<br>1、JNIEnv <em> 内部包含一个Pointer，Pointer指向Dalvik的JavaVM对象的Fanction Table, JNIEnv </em>关于程序执行环境的众多函数正是来源于Dalvik虚拟机<br>2、Android中每当一个Java线程第一次要调用本地C/C++代码时，Dalvik虚拟机实例会为该Java线程产生一个JNIEnv <em>指针<br>3、Java每条线程在和C/C++互相调用时，JNIEnv</em>是相互独立的，互不干扰<br>4、每本地的C/C++代码想获得当前线程所要使用的JNIEnv时，可以使用Dalvik VM对象的Java VM<em> jvm-&gt;getEnv()方法，该方法即会返回当前线程所在的JNIEnv</em><br>Java、Dalvik VM、C/C++的运行机制与流程<br>在Android的NDK中，Java、C/C++、Dalvik VM关系如下：<br>1、java的dex字节码和C/C++的*.so同时运行DalvikVM之内，共同使用一个进程空间。每次使用jni调用c/c++开辟一个线程去处理<br>2、java和C/C++可以相互调用，调用的关键是DalvikVM<br>3、一般而言，比较经典的模式是Java通过JNI的C组建和C++相互沟通，一般业务处理放在C/C++中<br>4、C++代码处于核心控制地位更具价值</p>
<p>当java需要C/C++代码时，在DalvikVM虚拟机中加载动态链接库时，会先调用JNI_Onload()函数，此时就会把javaVM对象的指针存储于C层JNI组建的全局环境中，在JAVA层调用C层的本地库函数时，调用C本地函数线程必然通过Dalvik VM来调用C本地函数，测试Dalvik虚拟机会为本地的C组建实例化一个JNIEnv指针，该指针指向Dalvik虚拟机的具体函数列表，当JNI的C组件调用java层方法和属性时，需要通过JNIEnv指针来进行调用。</p>
<p>当C++组件主动调用Java层方法时，需要通过JNI的C组件把JNIEnv指针传递给C++组件，此后，c++组件即可通过JNIEnv指针来掌控Java层代码。<br>总结</p>
<p>JNI是Java调用Native机制，是Java语言自己的特性全称为Java Native Interface，类似的还有微软.Net Framework上的p/invoke，可以让C#或Visual Basic.Net可以调用C/C++的API，所以说JNI和Android没有关系，在PC上开发Java的应用，如果运行在Windows平台使用JNI是是经常的，比如说读写Windows的注册表。而NDK是Google公司推出的帮助Android开发者通过C/C++本地语言编写应用的开发包，包含了C/C++的头文件、库文件、说明文档和示例代码，我们可以理解为Windows Platform SDK一样，是纯C/C++编写的，但是Android并不支持纯C/C++编写的应用，同时NDK提供的库和函数功能很有限，仅仅处理些算法效率敏感的问题，所以Android123推荐初学者学好Java后再学习JNI。</p>
<p>简单点说，用C语言生成一个库文件，在java中调用这个库文件的函数。JNI的过程比较复杂，生成.so需要大量操作，而NDK就是简化了这个过程。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2016/10/16/6、Linux/2、常用软件服务管理/nginx 命令详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/16/6、Linux/2、常用软件服务管理/nginx 命令详解/" itemprop="url">
                  nginx 命令详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2016-10-16 10:24:44" itemprop="dateCreated datePublished" datetime="2016-10-16T10:24:44+08:00">2016-10-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-04-13 10:26:39" itemprop="dateModified" datetime="2018-04-13T10:26:39+08:00">2018-04-13</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>sudo nginx #打开 nginx<br>nginx -s reload|reopen|stop|quit  #重新加载配置|重启|停止|退出 nginx<br>nginx -t   #测试配置是否有语法错误</p>
<p>nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives]</p>
<p>-?,-h           : 打开帮助信息<br>-v              : 显示版本信息并退出<br>-V              : 显示版本和配置选项信息，然后退出<br>-t              : 检测配置文件是否有语法错误，然后退出<br>-q              : 在检测配置文件期间屏蔽非错误信息<br>-s signal       : 给一个 nginx 主进程发送信号：stop（停止）, quit（退出）, reopen（重启）, reload（重新加载配置文件）<br>-p prefix       : 设置前缀路径（默认是：/usr/local/Cellar/nginx/1.2.6/）<br>-c filename     : 设置配置文件（默认是：/usr/local/etc/nginx/nginx.conf）<br>-g directives   : 设置配置文件外的全局指令</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2016/10/10/1、Java/1、java 基础/java关键字 Synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/10/1、Java/1、java 基础/java关键字 Synchronized/" itemprop="url">
                  java关键字 Synchronized
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2016-10-10 14:32:00" itemprop="dateCreated datePublished" datetime="2016-10-10T14:32:00+08:00">2016-10-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-08-06 10:06:48" itemprop="dateModified" datetime="2018-08-06T10:06:48+08:00">2018-08-06</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java关键字-Synchronized"><a href="#java关键字-Synchronized" class="headerlink" title="java关键字 Synchronized"></a>java关键字 Synchronized</h2><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p>
<ol>
<li>修饰一个对象，当一个线程访问被修饰的对象时，其他试图访问该对象的线程将会阻塞，直到该线程访问该对象结束。</li>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个实例方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<blockquote>
<p>A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。<br>B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</p>
</blockquote>
<h3 id="1、修饰一个对象"><a href="#1、修饰一个对象" class="headerlink" title="1、修饰一个对象"></a>1、修饰一个对象</h3><p>1.1、明确的给一个对象加锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(SomeObject obj)</span></span>&#123;</span><br><span class="line">   <span class="comment">//obj 锁定的对象</span></span><br><span class="line">   <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.2、没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  <span class="comment">// 特殊的instance变量</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">         <span class="comment">//TODO</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</p>
</blockquote>
<h3 id="2、修饰代码块"><a href="#2、修饰代码块" class="headerlink" title="2、修饰代码块"></a>2、修饰代码块</h3><p>2.1、一个线程访问一个对象中的同步代码块时，其他试图访问该对象的线程将被阻塞<br>2.2、当一个线程访问对象的一个同步代码块时，另一个线程仍然可以访问该对象中的非同步代码块。<br>用法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">             <span class="comment">//TODO</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、修饰一个实例方法"><a href="#3、修饰一个实例方法" class="headerlink" title="3、修饰一个实例方法"></a>3、修饰一个实例方法</h3><p>Synchronized修饰一个方法很简单，就是在方法的前面加synchronized， synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。<br>Synchronized作用于整个方法的写法。<br>写法一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写法二：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在定义接口方法时不能使用synchronized关键字。<br>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</p>
</blockquote>
<h3 id="4、修饰一个静态方法"><a href="#4、修饰一个静态方法" class="headerlink" title="4、修饰一个静态方法"></a>4、修饰一个静态方法</h3><p>用法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p>
<h3 id="5、修改一个类"><a href="#5、修改一个类" class="headerlink" title="5、修改一个类"></a>5、修改一个类</h3><p>用法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classA</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(ClassName.class) &#123;</span><br><span class="line">                <span class="comment">// todo</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>synchronized作用于一个类时，是给这个类加锁，并且类的所有对象用的是同一把锁。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2016/10/10/3、Android/1、Android 基础/音视频开发/Android系统播放短促音效/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/10/3、Android/1、Android 基础/音视频开发/Android系统播放短促音效/" itemprop="url">
                  Android系统播放短促音效
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2016-10-10 11:42:59" itemprop="dateCreated datePublished" datetime="2016-10-10T11:42:59+08:00">2016-10-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2017-11-14 15:42:48" itemprop="dateModified" datetime="2017-11-14T15:42:48+08:00">2017-11-14</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android系统播放短促音效"><a href="#Android系统播放短促音效" class="headerlink" title="Android系统播放短促音效"></a>Android系统播放短促音效</h1><h2 id="使用MediaPlayer实现一般音频播放"><a href="#使用MediaPlayer实现一般音频播放" class="headerlink" title="使用MediaPlayer实现一般音频播放"></a>使用<strong><em>MediaPlayer</em></strong>实现一般音频播放</h2><h3 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h3><ul>
<li>此类适合播放较大文件，此类文件应该存储在SD卡上，而不是在资源文件里，还有此类每次只能播放一个音频文件。</li>
<li>缺点：资源占用量较高，延迟时间较长；不支持多个音频同时播放。<br>使用MediaPlayer非常简单，当程序控制MediaPlayer对象装载音频完成后，程序可以调用MediaPlayer的如下三个方法进行播放控制。</li>
<li>start()：开始或恢复播放。</li>
<li>stop()：停止播放。</li>
<li>pause():暂停播放。<br>为了让MediaPlayer来装载指定的音频文件，MediaPlayer提供如下简单的静态方法。</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>static MediaPlayer create(Context context, Uri uri)</td>
<td>从执定Uri来装载音频文件，并返回新创建的MediaPlayer对象</td>
<td></td>
</tr>
<tr>
<td>static MediaPlayer create(Context context, int resid)</td>
<td>从resid资源的ID对应的资源文件中装载音频文件，并返回新创建的对象。</td>
</tr>
</tbody>
</table>
<p>上面方法用起来非常方便，但这两个方法每次都会返回新创建的MediaPlayer对象，如果程序需要使用MediaPlayer循环播放多个音频文件，使用MediaPlayer的静态create()方法就不太合适了，此时可通过MediaPlayer的setDataSource()方法来装载指定的音频文件。<br>MediaPlayer提供了如下方法来指定装载相应的音频文件。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>void setDataSource(String path)</td>
<td>指定装载path路径所代表的文件。</td>
<td></td>
</tr>
<tr>
<td>void setDataSource(FileDescriptor fd, long offset, long length)</td>
<td>指定装载fd所代表的的文件中从offset开始、长度为length的文件内容。</td>
<td></td>
</tr>
<tr>
<td>void setDataSource(Context context, Uri uri)</td>
<td>指定装载uri所代表的文件。</td>
<td></td>
</tr>
<tr>
<td>void setDataSource(FileDescriptor fd)</td>
<td>指定装载fd所代表的的文件。</td>
</tr>
</tbody>
</table>
<p>执行上面所示的setDataSource()方法后，MediaPlayer并未真正的去装载那些音频文件，还需要调用MediaPlayer的prepare()方法去准备音频。所谓“准备”是让MediaPlayer真正去装载音频文件。</p>
<p>除此之外，MediaPlayer还提供了一些绑定事件监听器的方法，用于监听MediaPlayer播放过程中所发生的特定事件。绑定事件监听器的方法如下。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>setOnCompletionListener()</td>
<td>为MediaPlayer的播放完成事件绑定事件监听器。</td>
<td></td>
</tr>
<tr>
<td>setOnErrorListener()</td>
<td>为MediaPlayer的播放错误事件绑定事件监听器</td>
<td></td>
</tr>
<tr>
<td>setOnPreparedListener()</td>
<td>为MediaPlayer调用Prepare()方法时触发该监听器。</td>
</tr>
</tbody>
</table>
<h3 id="2、知识进阶"><a href="#2、知识进阶" class="headerlink" title="2、知识进阶"></a>2、知识进阶</h3><p>播放不同来源的音频文件<br>1、播放应用中的资源文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer mediaPlayer = MediaPlayer.create(<span class="keyword">this</span>,R.raw.incomingcall);</span><br><span class="line">mediaPlayer.start()</span><br></pre></td></tr></table></figure></p>
<p>2、播放应用原始资源文件<br>播放应用原始资源的步骤：</p>
<ul>
<li>调用Context的getAssets()方法获取应用的AssetManager。</li>
<li>] 调用AssertManager对象的openFd(String name)方法代开指定的原始资源，该方法返回一个AssetFileDescriptor对象。</li>
<li>调用AssetFileDescriptor的getFileDescriptor()、getStartOffset和getLength()方法来获取音频文件的FileDescriptor、开始位置、长度等。</li>
<li>创建MediaPlayer对象(或利用已有的MediaPlayer对象)，并调用MediaPlayer对象的setDataSource(FileDescriptor fd, long offset, long length)方法来装载音频资源。</li>
<li>调用MediaPlayer对象的prepare()方法准备音频。</li>
<li>调用MediaPlayer的start()、pause()、stop()等方法控制播放即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AssetManager am = getAssets();</span><br><span class="line"><span class="comment">//打开指定音乐文件</span></span><br><span class="line">AssetFileDescriptor afd = am.openFd(music);</span><br><span class="line">MediaPlayer mediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line"><span class="comment">//使用MediaPlayer装载指定的声音文件</span></span><br><span class="line">mediaPlayer.setDataSource(afd.getFileDescriptor(),</span><br><span class="line">               afd.getStartOffset(),afd.getLength());</span><br><span class="line"><span class="comment">//准备声音</span></span><br><span class="line">mediaPlayer.prepare();</span><br><span class="line"><span class="comment">//播放</span></span><br><span class="line">mediaPlayer.start();</span><br></pre></td></tr></table></figure>
<p>3、播放外部存储器上的音频文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer mediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mediaPlayer.setDataSource(<span class="string">"/mnt/sdcard/mysong.mp3"</span>);</span><br><span class="line">mediaPlayer.prepare();</span><br><span class="line">mediaPlayer.start();</span><br></pre></td></tr></table></figure></p>
<p>4、播放来自网络的音频文件<br>有两种方式:<br>(1)直接使用MediaPlayer的静态方法create(Context context, Uri uri).<br>(2)调用MediaPlayer的setDataSource(Context context, Uri uri)方法装载Uri对对应的音频文件。<br>第(2)中方式的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"http://www.xxx.cn/abc.mp3"</span>);</span><br><span class="line">MediaPlayer mediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mediaPlayer.setDataSource(<span class="keyword">this</span>,uri);</span><br><span class="line">mediaPlayer.prepare();</span><br><span class="line">mediaPlayer.start();</span><br></pre></td></tr></table></figure></p>
<p>另外，MediaPlayer除了调用prepare()方法来准备声音之外，还可以调用prepareAsync()来准备声音。prepareAsync()与prepare()方法的区别在于，prepareAsync()是异步的，它不会阻塞当前的UI线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer mediaPlayer = <span class="keyword">new</span> MediaPlayer();  </span><br><span class="line"><span class="keyword">if</span> (mediaPlayer.isPlaying()) &#123;  </span><br><span class="line">   mediaPlayer.reset();<span class="comment">//重置为初始状态  </span></span><br><span class="line">&#125;  </span><br><span class="line">mediaPlayer.setDataSource(<span class="string">"/mnt/sdcard/god.mp3"</span>);  </span><br><span class="line">mediaPlayer.prepare();<span class="comment">//缓冲   </span></span><br><span class="line">mediaPlayer.start();<span class="comment">//开始或恢复播放  </span></span><br><span class="line">mediaPlayer.pause();<span class="comment">//暂停播放  </span></span><br><span class="line">mediaPlayer.start();<span class="comment">//恢复播放  </span></span><br><span class="line">mediaPlayer.stop();<span class="comment">//停止播放  </span></span><br><span class="line">mediaPlayer.release();<span class="comment">//释放资源  </span></span><br><span class="line">mediaPlayer.setOnCompletionListener(<span class="keyword">new</span> MediaPlayer.OnCompletionListener() &#123;<span class="comment">//播出完毕事件  </span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(MediaPlayer arg0)</span> </span>&#123;  </span><br><span class="line">      mediaPlayer.release();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">mediaPlayer.setOnErrorListener(<span class="keyword">new</span> MediaPlayer.OnErrorListener() &#123;<span class="comment">// 错误处理事件  </span></span><br><span class="line">         <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onError</span><span class="params">(MediaPlayer player, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;  </span><br><span class="line">  mediaPlayer.release();  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用-SoundPool-实现短促音效播放"><a href="#使用-SoundPool-实现短促音效播放" class="headerlink" title="使用 SoundPool 实现短促音效播放"></a>使用 <strong><em>SoundPool</em></strong> 实现短促音效播放</h2><h3 id="1、基础知识-1"><a href="#1、基础知识-1" class="headerlink" title="1、基础知识"></a>1、基础知识</h3><p>SoundPool（android.media.SoundPool），顾名思义是声音池的意思，主要用于播放一些较短的声音片段，支持从程序的资源或文件系统加载。与MediaPlayer相比，SoundPool的优势在于CPU资源占用量低和反应延迟小。另外，SoundPool还支持自行设置声音的品质、音量、播放比率等参数，支持通过ID对多个音频流进行管理。<br> 在Android开发中我们经常使用MediaPlayer来播放音频文件，但是MediaPlayer存在一些不足，例如：资源占用量较高、延迟时间较长、不支持多个音频同时播放等。这些缺点决定了MediaPlayer在某些场合的使用情况不会很理想，例如在对时间精准度要求相对较高的游戏开发中。<br>     在游戏开发中我们经常需要播放一些游戏音效（比如：子弹爆炸，物体撞击等），这些音效的共同特点是短促、密集、延迟程度小。在这样的场景下，我们可以使用SoundPool代替MediaPlayer来播放这些音效。 </p>
<p>SoundPool存在的缺陷<br>　   - SoundPool最大只能申请1M的内存空间，这就意味着我们只能用一些很短的声音片段，而不是用它来播放歌曲或者做游戏背景音乐。<br>　　- SoundPool提供了pause和stop方法，但这些方法建议最好不要轻易使用，因为有些时候它们可能会使你的程序莫名其妙的终止。建议使用这两个方法的时候尽可能多做测试工作，还有些朋友反映它们不会立即中止播放声音，而是把缓冲区里的数据播放完才会停下来，也许会多播放一秒钟。<br>　　- SoundPool的效率问题。其实SoundPool的效率在这些播放类中算是很好的了，但是有的朋友在G1中测试它还是有100ms左右的延迟，这可能会影响用户体验。也许这不能管SoundPool本身，因为到了性能比较好的Droid中这个延迟就可以让人接受了。<br>　　在现阶段SoundPool有这些缺陷，但也有着它不可替代的优点，基于这些我们建议大在如下情况中多使用SoundPool：<br>1、应用程序中的声效(按键提示音，消息等)<br>2、游戏中密集而短暂的声音(如多个飞船同时爆炸)<br> soundpool可以播一些短的反应速度要求高的声音，<br>比如游戏中的爆破声，而mediaplayer适合播放长点的。<br> 3、SoundPool载入音乐文件使用了独立的线程，不会阻塞UI主线程的操作。但是这里如果音效文件过大没有载入完成，我们调用play方法时可能产生严 重的后果，这里Android SDK提供了一个SoundPool.OnLoadCompleteListener类来帮助我们了解媒体文件是否载入完成，我们重载 onLoadComplete(SoundPool soundPool, int sampleId, int status) 方法即可获得。<br>4、 从上面的onLoadComplete方法可以看出该类有很多参数，比如类似id，是的SoundPool在load时可以处理多个媒体一次初始化并放入内存中，这里效率比MediaPlayer高了很多。<br>5、SoundPool类支持同时播放多个音效，这对于游戏来说是十分必要的，而MediaPlayer类是同步执行的只能一个文件一个文件的播放。</p>
<h3 id="1、实战使用"><a href="#1、实战使用" class="headerlink" title="1、实战使用"></a>1、实战使用</h3><blockquote>
<p>SoundPool API<br><img src="http://oymp4z5xr.bkt.clouddn.com/17-11-14/88330926.jpg" alt=""></p>
</blockquote>
<p>SoundPool提供一个Builder内部类，该内部类专门用于创建SoundPool。<br>注：从Android5.0开始，SoundPool的构造器被设为过时了，因此推荐使用SoundPool.Builder来创建SoundPool对象。</p>
<p>1、创建SoundPool对象<br>Android5.0之前<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soundPool = <span class="keyword">new</span> SoundPool(<span class="number">10</span>, AudioManager.STREAM_RING,<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<p>Android5.0之后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置音效池的属性</span></span><br><span class="line"> AudioAttributes audioAttributes = <span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                 <span class="comment">//设置音效使用场景</span></span><br><span class="line">                .setUsage(AudioAttributes.USAGE_NOTIFICATION)</span><br><span class="line"><span class="comment">//设置音效类型                                     .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建SoundPool对象               </span></span><br><span class="line"> soundPool = <span class="keyword">new</span> SoundPool.Builder()</span><br><span class="line">                 <span class="comment">//设置音效池属性</span></span><br><span class="line">                .setAudioAttributes(audioAttributes)</span><br><span class="line">                <span class="comment">//设置音效类型</span></span><br><span class="line">                .setMaxStreams(<span class="number">10</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p>
<p>2、加载声音<br>一旦得到SoundPool对象后，接下来就可调用SoundPool的多个重载的load()方法来加载声音了。SoundPool提供了如下load()方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int load (Context context, int resId, int priority)</td>
<td>从resId加载声音。</td>
</tr>
<tr>
<td>int load (FileDescriptor fd, long offset, long length, int priority)</td>
<td>从fd所对应的文件加载声音。</td>
</tr>
<tr>
<td>int load (AssetFileDescriptor afd, int priority)</td>
<td></td>
</tr>
<tr>
<td>int load (String path, int priority)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>上面的方法中都有一个priority参数，该参数目前还没有任何作用，Android建议将该参数设置为1，保持和未来的兼容性。</p>
</blockquote>
<p>返回值为该资源在Pool 中的Id<br>为了更好的管理SoundPool所加载的每个声音的ID，程序一般会使用HashMap&lt; Interger,Interger&gt;对象来管理声音。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,Integer&gt; soundMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">soundMap.put(<span class="number">1</span>,soundPool.load(<span class="keyword">this</span>,R.raw.one,<span class="number">1</span>));</span><br><span class="line">soundMap.put(<span class="number">2</span>,soundPool.load(<span class="keyword">this</span>,R.raw.two,<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通过soundMap.get(1)就可以拿到，soundPool.load(this,R.raw.one,1)的返回值得声音ID。<br>同理，soundMap.get(2)就可以拿到，soundPool.load(this,R.raw.two,1)的返回值得声音ID。</p>
</blockquote>
<p>3、播放声音<br>同过load()方法加载声音后，都会返回该声音的ID，以后程序就可以通过该声音的ID来播放声音了。SoundPool提供的播放指定声音的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">play</span> <span class="params">(<span class="keyword">int</span> soundID, <span class="keyword">float</span> leftVolume, <span class="keyword">float</span> rightVolume, <span class="keyword">int</span> priority, <span class="keyword">int</span> loop, <span class="keyword">float</span> rate)</span></span></span><br><span class="line"><span class="function">#Parameters</span></span><br><span class="line"><span class="function">#soundID a soundID returned by the <span class="title">load</span><span class="params">()</span> function</span></span><br><span class="line"><span class="function">#leftVolume  left volume <span class="title">value</span> <span class="params">(range = <span class="number">0.0</span> to <span class="number">1.0</span>)</span></span></span><br><span class="line"><span class="function">#rightVolume right volume <span class="title">value</span> <span class="params">(range = <span class="number">0.0</span> to <span class="number">1.0</span>)</span></span></span><br><span class="line"><span class="function">#priority    stream <span class="title">priority</span> <span class="params">(<span class="number">0</span> = lowest priority)</span></span></span><br><span class="line"><span class="function">#loop    loop <span class="title">mode</span> <span class="params">(<span class="number">0</span> = no loop, <span class="number">-1</span> = loop forever)</span></span></span><br><span class="line"><span class="function">#rate    playback <span class="title">rate</span> <span class="params">(<span class="number">1.0</span> = normal playback, range <span class="number">0.5</span> to <span class="number">2.0</span>)</span></span></span><br><span class="line"><span class="function">#</span></span><br><span class="line"><span class="function">#Returns</span></span><br><span class="line"><span class="function">#non-zero streamID <span class="keyword">if</span> successful, zero <span class="keyword">if</span> failed</span></span><br></pre></td></tr></table></figure></p>
<p>注：有时候play()函数的返回值为0,DDMS报的错是sample not ready的问题，也就是说是在load加载音乐文件出错，导致在play播放音乐时显示not ready； 在SoundPool中有setOnLoadCompleteListener方法用来判断音乐加载是否完成，因此解决方法如下：<br>(1)在音乐加载完成时间完成后播放<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">soundPool.setOnLoadCompleteListener(<span class="keyword">new</span> SoundPool.OnLoadCompleteListener() </span><br><span class="line">&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadComplete</span><span class="params">(SoundPool soundPool,</span></span></span><br><span class="line"><span class="function"><span class="params">            &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                streamIdOne </span></span></span><br><span class="line"><span class="function"><span class="params">                = soundPool.play(soundMap.get(<span class="number">1</span>)</span>,1,1,0,-1,1)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>(2)可直接在load后面加sleep（1000），具体时间根据加载的文件的多少大小而定，给程序足够的时间去加载初始化音频文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将加载的声音资源id放进此Map</span></span><br><span class="line">soundPoolMap.put(<span class="number">1</span>, soundPool.load(<span class="keyword">this</span>, R.raw.gamestart, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 给予初始化音乐文件足够时间</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、暂停播放<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">(<span class="keyword">int</span> streamID)</span></span></span><br><span class="line"><span class="function">#Parameters： </span></span><br><span class="line"><span class="function">#streamID a streamID returned by the <span class="title">play</span><span class="params">()</span> function</span></span><br></pre></td></tr></table></figure></p>
<p>简易开发步骤：<br>1、往项目的res/raw目录中放入音效文件。<br>2、新建SoundPool对象，然后调用SoundPool.load()加载音效，调用SoundPool.play()方法播放指定音效文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SoundPool pool;  </span><br><span class="line"><span class="comment">//指定声音池的最大音频流数目为10，声音品质为5  </span></span><br><span class="line">pool = <span class="keyword">new</span> SoundPool(<span class="number">10</span>, AudioManager.STREAM_SYSTEM, <span class="number">5</span>);  </span><br><span class="line"><span class="comment">//载入音频流，返回在池中的id  </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> sourceid = pool.load(<span class="keyword">this</span>, R.raw.pj, <span class="number">0</span>);  </span><br><span class="line"> <span class="comment">//播放音频，第二个参数为左声道音量;第三个参数为右声道音量;第四个参数为优先级；第五个参数为循环次数，0不循环，-1循环;第六个参数为速率，速率    最低0.5最高为2，1代表正常速度  </span></span><br><span class="line">pool.play(sourceid, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意事项<br>1、AudioFlinger could not  create track, status: -12<br>   SoundPool即音效池，在创建的时候 maxStream这个参数代表能够同时播放的最大音效数，这里切忌合理使用，写的太大后会报AudioFlinger could not  create track, status: -12 。。。。一旦报了这个错，你就听不到声音了，呵呵。<br> 2、256个音效<br>       当调用load方法的时候实际就是把音效加载到了 SoundPool中，此时返回的streamId其实就是该音效在SoundPool中的Id，这个ID从0还是1来着（有点记不清了） 递增，不过要注意的是，不要超过  256  这个临界点。也就是说第257个声音加载进去后，调用play方法其实是播不出来的，说不定还会挤掉一些前面加载好的声音。这个256的限制通过查看SDK源码基本就能了解清楚，它底层就那么实现的，用一个类似堆栈来存。<br>  3、unload方法和release方法<br>         如果你音效多，也不要指望unload方法来清除掉一些音效后再load新的进去，虽然unload后音效卸载了，但是前面分给它在SoundPool里面的Id可没有释放掉，也就是说这个时候你load新的进去只会在后面继续累加，然后累加多了就超过256了，然后就就听不到声音，然后就没有然后了。要想彻底清掉前面的音效请使用release方法，它会连内存中占用的资源一起释放掉。<br>  4、load需要一点点时间<br>      load后不要马上unload，load —play–unload的做法并不可取，不要load太大的音效，它只会申请1M的内存空间。SoundPool出错后通常会看到retuen的值是0。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liyy.org/2016/09/16/6、Linux/3、场景应用/手动搭建梯子/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liyy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AtomOne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/16/6、Linux/3、场景应用/手动搭建梯子/" itemprop="url">
                  手动搭建梯子
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2016-09-16 10:28:44" itemprop="dateCreated datePublished" datetime="2016-09-16T10:28:44+08:00">2016-09-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-08-07 17:32:07" itemprop="dateModified" datetime="2018-08-07T17:32:07+08:00">2018-08-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="手动搭建梯子"><a href="#手动搭建梯子" class="headerlink" title="手动搭建梯子"></a>手动搭建梯子</h2><p>当前梯子搭建主要使用Shadowsocks 和 v2ray</p>
<h3 id="1、Shadowsocks"><a href="#1、Shadowsocks" class="headerlink" title="1、Shadowsocks"></a>1、Shadowsocks</h3><p>参考<br><a href="https://teddysun.com/342.html" target="_blank" rel="noopener">Shadowsocks Python版一键安装脚本</a></p>
<h3 id="2、V2ray"><a href="#2、V2ray" class="headerlink" title="2、V2ray"></a>2、V2ray</h3><p>参考<br><a href="https://www.moerats.com/archives/3/" target="_blank" rel="noopener">V2ray多功能管理一键脚本，带配置文件下载功能</a></p>
<h4 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h4><p>请使用Xshell连接服务器，以获得完美的中文支持以及配置文件下载功能。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/v2ray.fun/master/install.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h4><p>运行<code>V2ray</code>，根据提示配置V2ray。配置完成导出配置文件<code>config.json</code></p>
<h4 id="2-3本地导入配置文件"><a href="#2-3本地导入配置文件" class="headerlink" title="2.3本地导入配置文件"></a>2.3本地导入配置文件</h4><p><img src="http://oymp4z5xr.bkt.clouddn.com/hexo/180518/g4lG4k9alk.png?imageslim" alt="mark"></p>
<p>导入配置文件<br><img src="http://oymp4z5xr.bkt.clouddn.com/hexo/180518/faeGAma55f.png?imageslim" alt="mark"><br>选择默认服务地址<br><img src="http://oymp4z5xr.bkt.clouddn.com/hexo/180518/fmCJG1LiDm.png?imageslim" alt="mark"><br>开启代理</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="liyy" />
            
              <p class="site-author-name" itemprop="name">liyy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">Tags</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/atom-li" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:1299854942@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/d531760428f2" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i>简书</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AtomOne</span>

  

  
</div>




  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.4.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
